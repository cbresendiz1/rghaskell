LiquidHaskell Version 0.8.2.4, Git revision b78152f170bb19f0ddb6e72bfa1e5b3343e5de3c (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.

[1;94m
**** DONE:  A-Normalization ****************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  A-Normalization ****************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  Extracted Core using GHC *******************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  Transformed Core ***************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  annotate ***********************************************************
[0m[1;90m 
[0m[1;92m
**** RESULT: SAFE **************************************************************
[0m[1;94m
**** DONE:  Extracted Core using GHC *******************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  Transformed Core ***************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  annotate ***********************************************************
[0m[1;90m 
[0m[1;91m
**** RESULT: UNSAFE ************************************************************
[0m

 /home/charly/Program/Haskell/rghaskell/src/CASList.hs:105:12-25: Error: Liquid Type Mismatch
  
 105 | myNext _ = error "myNext"
                  ^^^^^^^^^^^^^^
  
   Inferred type
     VV : {v : [Char] | v ~~ "myNext"
                        && len v == strLen "myNext"
                        && len v >= 0
                        && v == "myNext"}
  
   not a subtype of Required type
     VV : {VV : [Char] | false}
  


 /home/charly/Program/Haskell/rghaskell/src/CASList.hs:(249,15)-(279,48): Error: Totality Error
  
 249 |               case curNode of
 250 |                 Node y nextNode ->
 251 |                    if (x == y)
 252 |                    then -- node found and alive 
 253 |                       return True
 254 |                    else go curPtr -- continue
 255 |                 Null -> return False -- reached end of list
 256 |                 DelNode nextNode -> 
 257 | -- ## Now curNode=(DelNode nextNode), which is stable w.r.t. ListRG.
 258 | -- ## We get this as a refinement on a value s.t. pastValue curPtr curNode, so by SMT congruence,
 259 | -- ## pastValue curPtr (DelNode nextNode)
 260 | -- ## I'd be willing to specialize the field observation of "terminal states" if necessary, since
 261 | -- ## that's at least pretty general.
 262 | -- ## Need measure terminalValue :: RGRef a -> a
 263 | -- ## Need axiom pastIsTerminal :: r:RGRef<p,r> a -> v:a ->
 264 | --                                 pf(x:{x:a | x = v} -> y:a<r x> -> {z:a | z = y && z = x}) ->
 265 | --                                 {b:Bool | (((terminalValue r) = v) <=> (pastValue r v))}
 266 |                          -- atomically delete curNode by setting the next of prevNode to next of curNode
 267 |                          -- if this fails we simply move ahead
 268 |                         case prevNode of
 269 |                           -- TODO: Do I actually need rgListCAS here to get the types right, or did
 270 |                           -- using it just help inference give a better / more local error report?
 271 |                           Node prevVal _ -> do b <- rgListCAS prevPtr prevNode (Node prevVal (liquidAssume (axiom_pastIsTerminal curPtr curNode (terminal_listrg curPtr curNode) (terminal_listrg curPtr curNode)) nextNode))
 272 |                                                if b then go prevPtr else go curPtr
 273 |                           --Next line typechecks fine, switched to rgListCAS for consistency and to
 274 |                           --ensure rgListCAS wasn't breaking some useful inference
 275 |                           --Head _ -> do b <- rgCAS prevPtr prevNode (Head nextNode) any_stable_listrg
 276 |                           --Head _ -> do b <- rgListCAS prevPtr prevNode (Head nextNode)
 277 |                           Head _ -> do b <- rgListCAS prevPtr prevNode (Head (liquidAssume (axiom_pastIsTerminal curPtr curNode (terminal_listrg curPtr curNode) (terminal_listrg curPtr curNode)) nextNode))
 278 |                                        if b then go prevPtr else go curPtr
 279 |                           DelNode _ -> go curPtr    -- if parent deleted simply move ahead
  
  
 Your function is not total: not all patterns are defined.
 Hint: Use "--no-totality" to deactivate totality checking.


 /home/charly/Program/Haskell/rghaskell/src/CASList.hs:(268,25)-(279,48): Error: Totality Error
  
 268 |                         case prevNode of
 269 |                           -- TODO: Do I actually need rgListCAS here to get the types right, or did
 270 |                           -- using it just help inference give a better / more local error report?
 271 |                           Node prevVal _ -> do b <- rgListCAS prevPtr prevNode (Node prevVal (liquidAssume (axiom_pastIsTerminal curPtr curNode (terminal_listrg curPtr curNode) (terminal_listrg curPtr curNode)) nextNode))
 272 |                                                if b then go prevPtr else go curPtr
 273 |                           --Next line typechecks fine, switched to rgListCAS for consistency and to
 274 |                           --ensure rgListCAS wasn't breaking some useful inference
 275 |                           --Head _ -> do b <- rgCAS prevPtr prevNode (Head nextNode) any_stable_listrg
 276 |                           --Head _ -> do b <- rgListCAS prevPtr prevNode (Head nextNode)
 277 |                           Head _ -> do b <- rgListCAS prevPtr prevNode (Head (liquidAssume (axiom_pastIsTerminal curPtr curNode (terminal_listrg curPtr curNode) (terminal_listrg curPtr curNode)) nextNode))
 278 |                                        if b then go prevPtr else go curPtr
 279 |                           DelNode _ -> go curPtr    -- if parent deleted simply move ahead
  
  
 Your function is not total: not all patterns are defined.
 Hint: Use "--no-totality" to deactivate totality checking.
